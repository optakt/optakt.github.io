
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.6">
    
    
      
        <title>Testing Guide - Optakt Documentation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.a57b2b03.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../stylesheets/wide.css">
    
    
      


    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
      <script>var palette=__get("__palette");if(null!==palette&&"object"==typeof palette.color)for(var key in palette.color)document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#testing-guide" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Optakt Documentation" class="md-header__button md-logo" aria-label="Optakt Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Optakt Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Testing Guide
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="white" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Optakt Documentation" class="md-nav__button md-logo" aria-label="Optakt Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Optakt Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Introduction
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../process/" class="md-nav__link">
        Team Process
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../projects/" class="md-nav__link">
        Projects
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../design/" class="md-nav__link">
        Design Principles
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Testing Guide
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Testing Guide
      </a>
      
        


<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#unit-tests" class="md-nav__link">
    Unit Tests
  </a>
  
    <nav class="md-nav" aria-label="Unit Tests">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#naming-conventions" class="md-nav__link">
    Naming Conventions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#internal-unit-tests" class="md-nav__link">
    Internal Unit Tests
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mocks" class="md-nav__link">
    Mocks
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pseudorandom-generic-values" class="md-nav__link">
    Pseudorandom Generic Values
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parallelization" class="md-nav__link">
    Parallelization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#standard-testing-package" class="md-nav__link">
    Standard testing Package
  </a>
  
    <nav class="md-nav" aria-label="Standard testing Package">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#subtests-and-sub-benchmarks" class="md-nav__link">
    Subtests and Sub-benchmarks
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#table-driven-tests" class="md-nav__link">
    Table-Driven Tests
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#case-study-the-flow-dps-mapper" class="md-nav__link">
    Case Study: The Flow DPS Mapper
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#integration-tests" class="md-nav__link">
    Integration Tests
  </a>
  
    <nav class="md-nav" aria-label="Integration Tests">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build-tag" class="md-nav__link">
    Build Tag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    Examples
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#benchmarks" class="md-nav__link">
    Benchmarks
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          Style Guidelines
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Style Guidelines" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Style Guidelines
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../style/go/" class="md-nav__link">
        Go
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../style/markdown/" class="md-nav__link">
        Markdown
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          Knowledge Base
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Knowledge Base" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Knowledge Base
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../knowledge_base/glossary/" class="md-nav__link">
        Glossary
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../knowledge_base/flow/specification/" class="md-nav__link">
        Flow
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7_3" type="checkbox" id="__nav_7_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7_3">
          Flare
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Flare" data-md-level="2">
        <label class="md-nav__title" for="__nav_7_3">
          <span class="md-nav__icon md-icon"></span>
          Flare
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7_3_1" type="checkbox" id="__nav_7_3_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7_3_1">
          Consensus
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Consensus" data-md-level="3">
        <label class="md-nav__title" for="__nav_7_3_1">
          <span class="md-nav__icon md-icon"></span>
          Consensus
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7_3_1_1" type="checkbox" id="__nav_7_3_1_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7_3_1_1">
          Avalanche
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Avalanche" data-md-level="4">
        <label class="md-nav__title" for="__nav_7_3_1_1">
          <span class="md-nav__icon md-icon"></span>
          Avalanche
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../knowledge_base/flare/consensus/avalanche/concepts/" class="md-nav__link">
        Concepts
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../knowledge_base/flare/consensus/avalanche/specification/" class="md-nav__link">
        Specification
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7_3_1_2" type="checkbox" id="__nav_7_3_1_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7_3_1_2">
          Stellar
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Stellar" data-md-level="4">
        <label class="md-nav__title" for="__nav_7_3_1_2">
          <span class="md-nav__icon md-icon"></span>
          Stellar
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../knowledge_base/flare/consensus/stellar/concepts/" class="md-nav__link">
        Concepts
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../knowledge_base/flare/consensus/stellar/specification/" class="md-nav__link">
        Specification
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../knowledge_base/flare/specification/" class="md-nav__link">
        Specification
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="testing-guide">Testing Guide</h1>
<p>At Optakt, we consistently write tests to ensure a reliable engineering environment where quality is paramount.
Over the course of the product development life cycle, testing saves time and money, and helps developers write better code, more efficiently.
Untested code is fragile, difficult to maintain and becomes questionable as soon as changes are made.</p>
<p>This guide assumes that you are already familiar with Go testing.</p>
<h2 id="unit-tests">Unit Tests</h2>
<p>This section outlines a few of the rules we try to follow when it comes to Go unit tests.</p>
<h3 id="naming-conventions">Naming Conventions</h3>
<p>Unit tests should have consistent names.
The best way to go about it is to follow the <a href="https://pkg.go.dev/testing#hdr-Examples">official guidelines of the Go <code>testing</code> package</a>, which states that:</p>
<blockquote>
<p>The naming convention to declare tests for the package, a function <code>F</code>, a type <code>T</code> and method <code>M</code> on type <code>T</code> are:</p>
<div class="highlight"><pre><span></span><code>  <span class="kd">func</span> <span class="nx">Test</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="kd">func</span> <span class="nx">TestF</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="kd">func</span> <span class="nx">TestT</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
  <span class="kd">func</span> <span class="nx">TestT_M</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div>
</blockquote>
<p>When it comes to subtests, the names of individual subtests should be lowercased and concise.
The tests usually start with a subtest called <code>nominal case</code> which verifies that the tested component behaves as expected in a baseline situation, where no failures occur and no edge cases are handled.</p>
<h3 id="internal-unit-tests">Internal Unit Tests</h3>
<p>In most cases, packages can be tested using external tests only.
When writing tests for a package called <code>xyz</code>, the external tests should be in the same folder, but in a package called <code>xyz_test</code>.
This case is <a href="https://pkg.go.dev/cmd/go@master#hdr-Test_packages">handled by Go natively</a> and will therefore not result in complaints about there being two different packages within the same directory.
Of course, there are exceptions. If you need to test some internal logic, those tests must be in a file suffixed with <code>_internal_test.go</code>.</p>
<h3 id="mocks">Mocks</h3>
<p>When it comes to mocking dependencies for tests, we prefer to use simple hand-made mocks rather than to use testing frameworks to generate them.
The Go language makes it easy to do so elegantly by creating structures that implement the interfaces for dependencies of the tested code and exposing functions that match the interface's signature as attributes that can be overridden externally.</p>
<div class="highlight"><pre><span></span><code>    <span class="kn">package</span> <span class="nx">mocks</span>

    <span class="kn">import</span> <span class="p">(</span>
        <span class="s">&quot;testing&quot;</span>

        <span class="s">&quot;github.com/onflow/flow-go/ledger/complete/mtrie/trie&quot;</span>
    <span class="p">)</span>

    <span class="kd">type</span> <span class="nx">Loader</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">TrieFunc</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="o">*</span><span class="nx">Loader</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Helper</span><span class="p">()</span>

        <span class="nx">l</span> <span class="o">:=</span> <span class="nx">Loader</span><span class="p">{</span>
            <span class="nx">TrieFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">GenericTrie</span><span class="p">,</span> <span class="kc">nil</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">l</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Loader</span><span class="p">)</span> <span class="nx">Trie</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">TrieFunc</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div>
<p>Using those mocks is as simple as instantiating a baseline version of the mock and setting its attributes to the desired functions:</p>
<div class="highlight"><pre><span></span><code>    <span class="c1">// ...</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles failure to load checkpoint&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusEmpty</span><span class="p">)</span>

        <span class="nx">load</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">load</span><span class="p">.</span><span class="nx">CheckpointFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">.</span><span class="nx">load</span> <span class="p">=</span> <span class="nx">load</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">BootstrapState</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="c1">// ...</span>
</code></pre></div>
<h3 id="pseudorandom-generic-values">Pseudorandom Generic Values</h3>
<p>When using test data for unit tests, it is always a good idea to use random generated data as the inputs.
This avoids the bias where a test passes because it is given a valid set of inputs while some other inputs might have highlighted a flaw in the logic, by using an <em>unconstrained</em> data set.</p>
<p>In order for the tests to be repeatable and for results to be consistent though, the given inputs should not be completely random, but instead they should be pseudorandom, with the same initial seed, to ensure the same sequence of "random" tests.</p>
<p>Here is an example of such a value being generated.</p>
<div class="highlight"><pre><span></span><code>    <span class="kd">func</span> <span class="nx">GenericAddresses</span><span class="p">(</span><span class="nx">number</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
        <span class="c1">// Ensure consistent deterministic results.</span>
        <span class="nx">random</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">NewSource</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

        <span class="kd">var</span> <span class="nx">addresses</span> <span class="p">[]</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Address</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">number</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">address</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">Address</span>
            <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">.</span><span class="nx">PutUint64</span><span class="p">(</span><span class="nx">address</span><span class="p">[</span><span class="mi">0</span><span class="p">:],</span> <span class="nx">random</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">())</span>

            <span class="nx">addresses</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">addresses</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">addresses</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nx">GenericAddress</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">GenericAddresses</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="nx">index</span><span class="p">]</span>
    <span class="p">}</span>
</code></pre></div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While randomly generating valid inputs makes sense, randomly generating invalid inputs does not. In the case of invalid inputs, it is much better to have an exhaustive list of all types of cases that are expected to be invalid and always test each one of them.</p>
</div>
<h3 id="parallelization">Parallelization</h3>
<p>Since the version <code>1.7</code> of Go, tests can be run in parallel.
This can be done by calling <a href="https://pkg.go.dev/testing#T.Parallel"><code>t.Parallel</code></a> in each subtest.
Calling this function signals that the test is to be run in parallel with (and only with) other parallel tests, and the amount of tests running in parallel is limited by the value of <a href="https://pkg.go.dev/runtime#GOMAXPROCS"><code>runtime.GOMAXPROCS</code></a>.</p>
<p>There are multiple advantages to parallelizing tests:</p>
<ul>
<li>It ensures that regardless of the order in which inputs are given, components behave as expected.</li>
<li>It maximizes performance, which in turns results in a faster CI and a faster workflow for everyone, which allows us to write more tests and therefore produce more actionable data to find bugs as well as improve tests cases and coverage.</li>
<li>It makes it possible to ensure that the components you test are concurrency-safe</li>
</ul>
<div class="admonition danger">
<p class="admonition-title">Parallelizing table-driven tests</p>
<p>When it comes to table-driven tests, a common pitfall developers fall into is to call <code>t.Parallel</code> in their subtest without capturing the loop variable with their test case.</p>
<p>Here is an example of how it should be done:</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nx">TestGroupedParallel</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
        <span class="nx">tc</span> <span class="o">:=</span> <span class="nx">tc</span> <span class="c1">// capture range variable</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="nx">tc</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>
            <span class="o">...</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
<h3 id="standard-testing-package">Standard <code>testing</code> Package</h3>
<p>The standard <a href="https://pkg.go.dev/testing"><code>testing</code></a> package is very powerful, and does not require additional frameworks to be used efficiently.
The only exception we make to that are the <code>stretchr/testify/assert</code> and <code>stretchr/testify/require</code> packages which we use only for convenience, as they expose assertion functions that produce consistent outputs and make tests easy to understand.</p>
<h4 id="subtests-and-sub-benchmarks">Subtests and Sub-benchmarks</h4>
<p>The <code>testing</code> package exposes a <code>Run</code> method on the <code>T</code> type which makes it possible to nest tests within tests.
This can be very useful, as it enables creating a hierarchical structure within a test.</p>
<details class="example">
<summary>index_internal_test.go</summary>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nx">TestIndex</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;collections&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">collections</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCollections</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="nx">reader</span><span class="p">,</span> <span class="nx">writer</span><span class="p">,</span> <span class="nx">db</span> <span class="o">:=</span> <span class="nx">setupIndex</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">writer</span><span class="p">.</span><span class="nx">Collections</span><span class="p">(</span><span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">collections</span><span class="p">))</span>
        <span class="c1">// Close the writer to make it commit its transactions.</span>
        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">writer</span><span class="p">.</span><span class="nx">Close</span><span class="p">())</span>

        <span class="c1">// NOTE: The following subtests should NOT be run in parallel, because of the deferral</span>
        <span class="c1">// to close the database above.</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;retrieve collection by ID&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">got</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reader</span><span class="p">.</span><span class="nx">Collection</span><span class="p">(</span><span class="nx">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">ID</span><span class="p">())</span>

            <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">got</span><span class="p">)</span>
        <span class="p">})</span>

        <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;retrieve collections by height&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">got</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reader</span><span class="p">.</span><span class="nx">CollectionsByHeight</span><span class="p">(</span><span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">)</span>

            <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">ElementsMatch</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCollectionIDs</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nx">got</span><span class="p">)</span>
        <span class="p">})</span>

        <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;retrieve transactions from collection&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// For now this index is not used.</span>
        <span class="p">})</span>
    <span class="p">})</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
</details>
<h4 id="table-driven-tests">Table-Driven Tests</h4>
<p>It makes a lot of sense to use subtests when testing the behavior of complex components, but it is better to use <a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests">table-driven tests</a> when testing a simple function with an expected output for a given input, and that there are many cases to cover.
For such cases, table-driven tests massively improve clarity and readability.</p>
<p>They should not be used blindly for all tests, however.
In cases where the tested component is complex and that testing its methods cannot be simplified to a common setup, call to a function and assertion of the output, trying to use table-driven tests at all costs might lead to messy code, where the subtest which runs the test case is full of conditions to try to handle each separate setup.
This is usually a sign that using simple tests and subtests would be a better approach.</p>
<h3 id="case-study-the-flow-dps-mapper">Case Study: The Flow DPS Mapper</h3>
<p>Sometimes, a core piece of software might seem impossible to test.
That was the case for the mapper component in Flow DPS at some point, where its main function consisted of a 453-lines-long loop which orchestrated the use of all the other components of the application.</p>
<details class="example">
<summary>mapper_old.go</summary>
<div class="highlight"><pre><span></span><code><span class="kn">package</span> <span class="nx">mapper</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;bytes&quot;</span>
    <span class="s">&quot;context&quot;</span>
    <span class="s">&quot;errors&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;os&quot;</span>
    <span class="s">&quot;sort&quot;</span>
    <span class="s">&quot;sync&quot;</span>

    <span class="s">&quot;github.com/gammazero/deque&quot;</span>
    <span class="s">&quot;github.com/rs/zerolog&quot;</span>

    <span class="s">&quot;github.com/onflow/flow-go/ledger&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/ledger/complete/mtrie/flattener&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/ledger/complete/mtrie/node&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/ledger/complete/mtrie/trie&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/ledger/complete/wal&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/model/flow&quot;</span>

    <span class="s">&quot;github.com/optakt/flow-dps/models/dps&quot;</span>
    <span class="s">&quot;github.com/optakt/flow-dps/models/index&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Mapper</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">log</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span>
    <span class="nx">cfg</span> <span class="nx">Config</span>

    <span class="nx">chain</span> <span class="nx">Chain</span>
    <span class="nx">feed</span>  <span class="nx">Feeder</span>
    <span class="nx">index</span> <span class="nx">index</span><span class="p">.</span><span class="nx">Writer</span>

    <span class="nx">wg</span>   <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="nx">stop</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// New creates a new mapper that uses chain data to map trie updates to blocks</span>
<span class="c1">// and then passes on the details to the indexer for indexing.</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">log</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span><span class="p">,</span> <span class="nx">chain</span> <span class="nx">Chain</span><span class="p">,</span> <span class="nx">feed</span> <span class="nx">Feeder</span><span class="p">,</span> <span class="nx">index</span> <span class="nx">index</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">options</span> <span class="o">...</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Config</span><span class="p">))</span> <span class="p">(</span><span class="o">*</span><span class="nx">Mapper</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// We don&#39;t use a checkpoint by default. The options can set one, in which</span>
    <span class="c1">// case we will add the checkpoint as a finalized state commitment in our</span>
    <span class="c1">// trie registry.</span>
    <span class="nx">cfg</span> <span class="o">:=</span> <span class="nx">Config</span><span class="p">{</span>
        <span class="nx">CheckpointFile</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
        <span class="nx">PostProcessing</span><span class="p">:</span> <span class="nx">PostNoop</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">option</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">options</span> <span class="p">{</span>
        <span class="nx">option</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cfg</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Check if the checkpoint file exists.</span>
    <span class="k">if</span> <span class="nx">cfg</span><span class="p">.</span><span class="nx">CheckpointFile</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">stat</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">CheckpointFile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid checkpoint file: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">stat</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid checkpoint file: directory&quot;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">i</span> <span class="o">:=</span> <span class="nx">Mapper</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">:</span>   <span class="nx">log</span><span class="p">,</span>
        <span class="nx">chain</span><span class="p">:</span> <span class="nx">chain</span><span class="p">,</span>
        <span class="nx">feed</span><span class="p">:</span>  <span class="nx">feed</span><span class="p">,</span>
        <span class="nx">index</span><span class="p">:</span> <span class="nx">index</span><span class="p">,</span>
        <span class="nx">cfg</span><span class="p">:</span>   <span class="nx">cfg</span><span class="p">,</span>
        <span class="nx">wg</span><span class="p">:</span>    <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{},</span>
        <span class="nx">stop</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mapper</span><span class="p">)</span> <span class="nx">Stop</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">stop</span><span class="p">)</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
        <span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
    <span class="p">}()</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Done</span><span class="p">():</span>
        <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Err</span><span class="p">()</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NOTE: We might want to move height and tree (checkpoint) to parameters of the</span>
<span class="c1">// run function; that would make it quite easy to resume from an arbitrary</span>
<span class="c1">// point in the LedgerWAL and get rid of the related struct fields.</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mapper</span><span class="p">)</span> <span class="nx">Run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>

    <span class="c1">// We start trying to map at the root height.</span>
    <span class="nx">height</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Root</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get root height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// We always initialize an empty state trie to refer to the first step</span>
    <span class="c1">// before the checkpoint. If there is no checkpoint, then the step after the</span>
    <span class="c1">// checkpoint will also just be the empty trie. Otherwise, the second trie</span>
    <span class="c1">// will load the checkpoint trie.</span>
    <span class="nx">empty</span> <span class="o">:=</span> <span class="nx">trie</span><span class="p">.</span><span class="nx">NewEmptyMTrie</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nx">tree</span> <span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span>
    <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">CheckpointFile</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">tree</span> <span class="p">=</span> <span class="nx">empty</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;checkpoint rebuild started&quot;</span><span class="p">)</span>
        <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">CheckpointFile</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not open checkpoint file: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">checkpoint</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wal</span><span class="p">.</span><span class="nx">ReadCheckpoint</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not read checkpoint: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">trees</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">flattener</span><span class="p">.</span><span class="nx">RebuildTries</span><span class="p">(</span><span class="nx">checkpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not rebuild tries: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">trees</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;should only have one trie in root checkpoint (tries: %d)&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">trees</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="nx">tree</span> <span class="p">=</span> <span class="nx">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;checkpoint rebuild finished&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;path collection started&quot;</span><span class="p">)</span>

    <span class="c1">// We have to index all of the paths from the checkpoint; otherwise, we will</span>
    <span class="c1">// miss every single one of the bootstrapped registers.</span>
    <span class="nx">paths</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">AllPayloads</span><span class="p">()))</span>
    <span class="nx">queue</span> <span class="o">:=</span> <span class="nx">deque</span><span class="p">.</span><span class="nx">New</span><span class="p">()</span>
    <span class="nx">root</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">RootNode</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">queue</span><span class="p">.</span><span class="nx">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">PopBack</span><span class="p">().(</span><span class="o">*</span><span class="nx">node</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">IsLeaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">path</span> <span class="o">:=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Path</span><span class="p">()</span>
            <span class="nx">paths</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="o">*</span><span class="nx">path</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">LeftChild</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">queue</span><span class="p">.</span><span class="nx">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">LeftChild</span><span class="p">())</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">RightChild</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">queue</span><span class="p">.</span><span class="nx">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">RightChild</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;paths&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;path collection finished&quot;</span><span class="p">)</span>

    <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;path sorting started&quot;</span><span class="p">)</span>

    <span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Compare</span><span class="p">(</span><span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][:],</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">j</span><span class="p">][:])</span> <span class="p">&lt;</span> <span class="mi">0</span>
    <span class="p">})</span>

    <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;path sorting finished&quot;</span><span class="p">)</span>

    <span class="c1">// When trying to go from one finalized block to the next, we keep a list</span>
    <span class="c1">// of intermediary tries until the full set of transitions have been</span>
    <span class="c1">// identified. We keep track of these transitions as steps in this map.</span>
    <span class="nx">steps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">]</span><span class="o">*</span><span class="nx">Step</span><span class="p">)</span>

    <span class="c1">// We start at an &quot;imaginary&quot; step that refers to an empty trie, has no</span>
    <span class="c1">// paths and no previous commit. We consider this step already done, so it</span>
    <span class="c1">// will never be indexed; it&#39;s merely used as the sentinel value for</span>
    <span class="c1">// stopping when we index the first block. It also makes sure that we don&#39;t</span>
    <span class="c1">// return a `nil` trie if we abort indexing before the first block is done.</span>
    <span class="nx">emptyCommit</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span>
    <span class="nx">steps</span><span class="p">[</span><span class="nx">emptyCommit</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Step</span><span class="p">{</span>
        <span class="nx">Commit</span><span class="p">:</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">{},</span>
        <span class="nx">Paths</span><span class="p">:</span>  <span class="kc">nil</span><span class="p">,</span>
        <span class="nx">Tree</span><span class="p">:</span>   <span class="nx">empty</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// We then add a second step that refers to the first step that is already</span>
    <span class="c1">// done, which uses the commit of the initial state trie after the</span>
    <span class="c1">// checkpoint has been loaded, and contains all of the paths found in the</span>
    <span class="c1">// initial checkpoint state trie. This will make sure that we index all the</span>
    <span class="c1">// data from the checkpoint as part of the first block.</span>
    <span class="nx">rootCommit</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">())</span>
    <span class="nx">steps</span><span class="p">[</span><span class="nx">rootCommit</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Step</span><span class="p">{</span>
        <span class="nx">Commit</span><span class="p">:</span> <span class="nx">emptyCommit</span><span class="p">,</span>
        <span class="nx">Paths</span><span class="p">:</span>  <span class="nx">paths</span><span class="p">,</span>
        <span class="nx">Tree</span><span class="p">:</span>   <span class="nx">tree</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// This is how we let the indexing loop know that the first &quot;imaginary&quot; step</span>
    <span class="c1">// was already indexed. The `commitPrev` value is used as a sentinel value</span>
    <span class="c1">// for when to stop going backwards through the steps when indexing a block.</span>
    <span class="c1">// This means the value is always set to the last already indexed step.</span>
    <span class="nx">commitPrev</span> <span class="o">:=</span> <span class="nx">emptyCommit</span>

    <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;state indexing started&quot;</span><span class="p">)</span>

    <span class="c1">// Next, we launch into the loop that is responsible for mapping all</span>
    <span class="c1">// incoming trie updates to a block. The loop itself has no concept of what</span>
    <span class="c1">// the next state commitment is that we should look at. It will simply try</span>
    <span class="c1">// to find a previous step for _any_ trie update that comes in. This means</span>
    <span class="c1">// that the first trie update needs to either apply to the empty trie or to</span>
    <span class="c1">// the trie after the checkpoint in order to be processed.</span>
    <span class="nx">once</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span><span class="p">{}</span>
<span class="nx">Outer</span><span class="p">:</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// We want to check in this tight loop if we want to quit, just in case</span>
        <span class="c1">// we get stuck on a timed out network connection.</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">m</span><span class="p">.</span><span class="nx">stop</span><span class="p">:</span>
            <span class="k">break</span> <span class="nx">Outer</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="c1">// keep going</span>
        <span class="p">}</span>

        <span class="nx">log</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span>
            <span class="nx">Uint64</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">,</span> <span class="nx">height</span><span class="p">).</span>
            <span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit_prev&quot;</span><span class="p">,</span> <span class="nx">commitPrev</span><span class="p">[:]).</span><span class="nx">Logger</span><span class="p">()</span>

        <span class="c1">// As a first step, we retrieve the state commitment of the finalized</span>
        <span class="c1">// block at the current height; we start at the root height and then</span>
        <span class="c1">// increase it each time we are done indexing a block. Once an applied</span>
        <span class="c1">// trie update gives us a state trie with the same root hash as</span>
        <span class="c1">// `commitNext`, we have reached the end state of the next finalized</span>
        <span class="c1">// block and can index all steps in-between for that block height.</span>
        <span class="nx">commitNext</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Commit</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span>

        <span class="c1">// If the retrieval times out, it&#39;s possible that we are on a live chain</span>
        <span class="c1">// and the next block has not been finalized yet. We should thus simply</span>
        <span class="c1">// retry until we have a new block.</span>
        <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrTimeout</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Warn</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;commit retrieval timed out, retrying&quot;</span><span class="p">)</span>
            <span class="k">continue</span> <span class="nx">Outer</span>
        <span class="p">}</span>

        <span class="c1">// If we have reached the end of the finalized blocks, we are probably</span>
        <span class="c1">// on a historical chain and there are no more finalized blocks for the</span>
        <span class="c1">// related spork. We can exit without error.</span>
        <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrFinished</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;reached end of finalized chain&quot;</span><span class="p">)</span>
            <span class="k">break</span> <span class="nx">Outer</span>
        <span class="p">}</span>

        <span class="c1">// Any other error should not happen and should crash explicitly.</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not retrieve next commit (height: %d): %w&quot;</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">log</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit_next&quot;</span><span class="p">,</span> <span class="nx">commitNext</span><span class="p">[:]).</span><span class="nx">Logger</span><span class="p">()</span>

    <span class="nx">Inner</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="c1">// We want to check in this tight loop if we want to quit, just in case</span>
            <span class="c1">// we get stuck on a timed out network connection.</span>
            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">m</span><span class="p">.</span><span class="nx">stop</span><span class="p">:</span>
                <span class="k">break</span> <span class="nx">Outer</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="c1">// keep going</span>
            <span class="p">}</span>

            <span class="c1">// When we have the state commitment of the next finalized block, we</span>
            <span class="c1">// check to see if we find a trie for it in our steps. If we do, it</span>
            <span class="c1">// means that we have steps from the last finalized block to the</span>
            <span class="c1">// finalized block at the current height. This condition will</span>
            <span class="c1">// trigger immediately for every empty block.</span>
            <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">commitNext</span><span class="p">]</span>
            <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nx">Inner</span>
            <span class="p">}</span>

            <span class="c1">// If we don&#39;t find a trie for the current state commitment, we need</span>
            <span class="c1">// to keep applying trie updates to state tries until one of them</span>
            <span class="c1">// does have the correct commit. We simply feed the next trie update</span>
            <span class="c1">// here.</span>
            <span class="nx">update</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Update</span><span class="p">()</span>

            <span class="c1">// Once more, we might be on a live spork and the next delta might not</span>
            <span class="c1">// be available yet. In that case, keep trying.</span>
            <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrTimeout</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nx">Warn</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;delta retrieval timed out, retrying&quot;</span><span class="p">)</span>
                <span class="k">continue</span> <span class="nx">Inner</span>
            <span class="p">}</span>

            <span class="c1">// Similarly, if no more deltas are available, we reached the end of</span>
            <span class="c1">// the WAL and we are done reconstructing the execution state.</span>
            <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrFinished</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;reached end of delta log&quot;</span><span class="p">)</span>
                <span class="k">break</span> <span class="nx">Outer</span>
            <span class="p">}</span>

            <span class="c1">// Other errors should fail execution as they should not happen.</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not retrieve next delta: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="c1">// NOTE: We used to require a copy of the `RootHash` here, when it</span>
            <span class="c1">// was still a byte slice, as the underlying slice was being reused.</span>
            <span class="c1">// It was changed to a value type that is always copied now.</span>
            <span class="nx">commitBefore</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">(</span><span class="nx">update</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">)</span>

            <span class="nx">log</span> <span class="o">:=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit_before&quot;</span><span class="p">,</span> <span class="nx">commitBefore</span><span class="p">[:]).</span><span class="nx">Logger</span><span class="p">()</span>

            <span class="c1">// Once we have our new update and know which trie it should be</span>
            <span class="c1">// applied to, we check to see if we have such a trie in our current</span>
            <span class="c1">// steps. If not, we can simply skip it; this can happen, for</span>
            <span class="c1">// example, when there is an execution fork and the trie update</span>
            <span class="c1">// applies to an obsolete part of the blockchain history.</span>
            <span class="nx">step</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">commitBefore</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;skipping trie update without matching trie&quot;</span><span class="p">)</span>
                <span class="k">continue</span> <span class="nx">Inner</span>
            <span class="p">}</span>

            <span class="c1">// We de-duplicate the paths and payloads here. This replicates some</span>
            <span class="c1">// code that is part of the execution node and has moved between</span>
            <span class="c1">// different layers of the architecture. We keep it to be safe for</span>
            <span class="c1">// all versions of the Flow dependencies.</span>
            <span class="c1">// NOTE: Past versions of this code required paths to be copied,</span>
            <span class="c1">// because the underlying slice was being re-used. In contrary,</span>
            <span class="c1">// deep-copying payloads was a bad idea, because they were already</span>
            <span class="c1">// being copied by the trie insertion code, and it would have led to</span>
            <span class="c1">// twice the memory usage.</span>
            <span class="nx">paths</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">update</span><span class="p">.</span><span class="nx">Paths</span><span class="p">))</span>
            <span class="nx">lookup</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span>
            <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">path</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">update</span><span class="p">.</span><span class="nx">Paths</span> <span class="p">{</span>
                <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lookup</span><span class="p">[</span><span class="nx">path</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
                    <span class="nx">paths</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">lookup</span><span class="p">[</span><span class="nx">path</span><span class="p">]</span> <span class="p">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">Payloads</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Compare</span><span class="p">(</span><span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">][:],</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">j</span><span class="p">][:])</span> <span class="p">&lt;</span> <span class="mi">0</span>
            <span class="p">})</span>
            <span class="nx">payloads</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">))</span>
            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">path</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">paths</span> <span class="p">{</span>
                <span class="nx">payloads</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">payloads</span><span class="p">,</span> <span class="o">*</span><span class="nx">lookup</span><span class="p">[</span><span class="nx">path</span><span class="p">])</span>
            <span class="p">}</span>

            <span class="c1">// We can now apply the trie update to the state trie as it was at</span>
            <span class="c1">// the previous step. This is where the trie code will deep-copy the</span>
            <span class="c1">// payloads.</span>
            <span class="c1">// NOTE: It&#39;s important that we don&#39;t shadow the variable here,</span>
            <span class="c1">// otherwise the root trie will never go out of scope and we will</span>
            <span class="c1">// never garbage collect any of the root trie payloads that have</span>
            <span class="c1">// been replaced by subsequent trie updates.</span>
            <span class="nx">tree</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">trie</span><span class="p">.</span><span class="nx">NewTrieWithUpdatedRegisters</span><span class="p">(</span><span class="nx">step</span><span class="p">.</span><span class="nx">Tree</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="nx">payloads</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not update trie: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="c1">// We then store the new trie along with the state commitment of its</span>
            <span class="c1">// parent and the paths that were changed. This will make it</span>
            <span class="c1">// available for subsequent trie updates to be applied to it, and it</span>
            <span class="c1">// will also allow us to reconstruct the payloads changed in this</span>
            <span class="c1">// step by retrieving them directly from the trie with the given</span>
            <span class="c1">// paths.</span>
            <span class="nx">commitAfter</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">())</span>
            <span class="nx">step</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Step</span><span class="p">{</span>
                <span class="nx">Commit</span><span class="p">:</span> <span class="nx">commitBefore</span><span class="p">,</span>
                <span class="nx">Paths</span><span class="p">:</span>  <span class="nx">paths</span><span class="p">,</span>
                <span class="nx">Tree</span><span class="p">:</span>   <span class="nx">tree</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nx">steps</span><span class="p">[</span><span class="nx">commitAfter</span><span class="p">]</span> <span class="p">=</span> <span class="nx">step</span>

            <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit_after&quot;</span><span class="p">,</span> <span class="nx">commitAfter</span><span class="p">[:]).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;trie update applied&quot;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// At this point we have identified a step that has lead to the state</span>
        <span class="c1">// commitment of the finalized block at the current height. We can</span>
        <span class="c1">// retrieve some additional indexing data, such as the block header and</span>
        <span class="c1">// the events that resulted from transactions in the block.</span>
        <span class="nx">header</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Header</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not retrieve header: %w (height: %d)&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">events</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Events</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not retrieve events: %w (height: %d)&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">transactions</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not retrieve transactions: %w (height: %d)&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">collections</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Collections</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not retrieve collections: %w (height: %d)&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">blockID</span> <span class="o">:=</span> <span class="nx">header</span><span class="p">.</span><span class="nx">ID</span><span class="p">()</span>

        <span class="c1">// TODO: Refactor the mapper in https://github.com/optakt/flow-dps/issues/128</span>
        <span class="c1">// and replace naive if statements around indexing.</span>

        <span class="c1">// We then index the data for the finalized block at the current height.</span>
        <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">IndexHeaders</span> <span class="p">{</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">Header</span><span class="p">(</span><span class="nx">height</span><span class="p">,</span> <span class="nx">header</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index header: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">IndexCommit</span> <span class="p">{</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">Commit</span><span class="p">(</span><span class="nx">height</span><span class="p">,</span> <span class="nx">commitNext</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index commit: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">IndexEvents</span> <span class="p">{</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">Events</span><span class="p">(</span><span class="nx">height</span><span class="p">,</span> <span class="nx">events</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index events: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">IndexBlocks</span> <span class="p">{</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">Height</span><span class="p">(</span><span class="nx">blockID</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index block heights: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">IndexTransactions</span> <span class="p">{</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">(</span><span class="nx">blockID</span><span class="p">,</span> <span class="nx">collections</span><span class="p">,</span> <span class="nx">transactions</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index transactions: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// In order to index the payloads, we step back from the state</span>
        <span class="c1">// commitment of the finalized block at the current height to the state</span>
        <span class="c1">// commitment of the last finalized block that was indexed. For each</span>
        <span class="c1">// step, we collect all the payloads by using the paths for the step and</span>
        <span class="c1">// index them as we go.</span>
        <span class="c1">// NOTE: We keep track of the paths for which we already indexed</span>
        <span class="c1">// payloads, so we can skip them in earlier steps. One inherent benefit</span>
        <span class="c1">// of stepping from the last step to the first step is that this will</span>
        <span class="c1">// automatically use only the latest update of a register, which is</span>
        <span class="c1">// exactly what we want.</span>
        <span class="nx">commit</span> <span class="o">:=</span> <span class="nx">commitNext</span>
        <span class="nx">updated</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span>
        <span class="k">for</span> <span class="nx">commit</span> <span class="o">!=</span> <span class="nx">commitPrev</span> <span class="p">{</span>

            <span class="c1">// In the first part, we get the step we are currently at and filter</span>
            <span class="c1">// out any paths that have already been updated.</span>
            <span class="nx">step</span> <span class="o">:=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">commit</span><span class="p">]</span>
            <span class="nx">paths</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">step</span><span class="p">.</span><span class="nx">Paths</span><span class="p">))</span>
            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">path</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">step</span><span class="p">.</span><span class="nx">Paths</span> <span class="p">{</span>
                <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">updated</span><span class="p">[</span><span class="nx">path</span><span class="p">]</span>
                <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
                <span class="nx">paths</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
                <span class="nx">updated</span><span class="p">[</span><span class="nx">path</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">IndexPayloads</span> <span class="p">{</span>
                <span class="nx">commit</span> <span class="p">=</span> <span class="nx">step</span><span class="p">.</span><span class="nx">Commit</span>
                <span class="k">continue</span>
            <span class="p">}</span>

            <span class="c1">// We then divide the remaining paths into chunks of 1000. For each</span>
            <span class="c1">// batch, we retrieve the payloads from the state trie as it was at</span>
            <span class="c1">// the end of this block and index them.</span>
            <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
            <span class="nx">n</span> <span class="o">:=</span> <span class="mi">1000</span>
            <span class="nx">total</span> <span class="o">:=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">n</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;num_paths&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)).</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;num_batches&quot;</span><span class="p">,</span> <span class="nx">total</span><span class="p">).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;path batching executed&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="nx">start</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">);</span> <span class="nx">start</span> <span class="o">+=</span> <span class="nx">n</span> <span class="p">{</span>
                <span class="c1">// This loop may take a while, especially for the root checkpoint</span>
                <span class="c1">// updates, so check if we should quit.</span>
                <span class="k">select</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">m</span><span class="p">.</span><span class="nx">stop</span><span class="p">:</span>
                    <span class="k">break</span> <span class="nx">Outer</span>
                <span class="k">default</span><span class="p">:</span>
                    <span class="c1">// keep going</span>
                <span class="p">}</span>

                <span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">n</span>
                <span class="k">if</span> <span class="nx">end</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">end</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">batch</span> <span class="o">:=</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">]</span>
                <span class="nx">payloads</span> <span class="o">:=</span> <span class="nx">step</span><span class="p">.</span><span class="nx">Tree</span><span class="p">.</span><span class="nx">UnsafeRead</span><span class="p">(</span><span class="nx">batch</span><span class="p">)</span>
                <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">Payloads</span><span class="p">(</span><span class="nx">height</span><span class="p">,</span> <span class="nx">batch</span><span class="p">,</span> <span class="nx">payloads</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index payloads: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
                <span class="p">}</span>

                <span class="nx">count</span><span class="o">++</span>

                <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;batch&quot;</span><span class="p">,</span> <span class="nx">count</span><span class="p">).</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;start&quot;</span><span class="p">,</span> <span class="nx">start</span><span class="p">).</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;end&quot;</span><span class="p">,</span> <span class="nx">end</span><span class="p">).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;path batch indexed&quot;</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="c1">// Finally, we forward the commit to the previous trie update and</span>
            <span class="c1">// repeat until we have stepped all the way back to the last indexed</span>
            <span class="c1">// commit.</span>
            <span class="nx">commit</span> <span class="p">=</span> <span class="nx">step</span><span class="p">.</span><span class="nx">Commit</span>
        <span class="p">}</span>

        <span class="c1">// At this point, we can delete any trie that does not correspond to</span>
        <span class="c1">// the state that we have just reached. This will allow the garbage</span>
        <span class="c1">// collector to free up any payload that has been changed and which is</span>
        <span class="c1">// no longer part of the state trie at the newly indexed finalized</span>
        <span class="c1">// block.</span>
        <span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">steps</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">key</span> <span class="o">!=</span> <span class="nx">commitNext</span> <span class="p">{</span>
                <span class="nb">delete</span><span class="p">(</span><span class="nx">steps</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Last but not least, we take care of properly indexing the height of</span>
        <span class="c1">// the first indexed block and the height of the last indexed block.</span>
        <span class="nx">once</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">First</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span> <span class="p">})</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index first height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">Last</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index last height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// We have now successfully indexed all state trie changes and other</span>
        <span class="c1">// data at the current height. We set the last indexed step to the last</span>
        <span class="c1">// step from our current height, and then increase the height to start</span>
        <span class="c1">// the indexing of the next block.</span>
        <span class="nx">commitPrev</span> <span class="p">=</span> <span class="nx">commitNext</span>
        <span class="nx">height</span><span class="o">++</span>

        <span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span>
            <span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;block&quot;</span><span class="p">,</span> <span class="nx">blockID</span><span class="p">[:]).</span>
            <span class="nx">Int</span><span class="p">(</span><span class="s">&quot;num_changes&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">updated</span><span class="p">)).</span>
            <span class="nx">Int</span><span class="p">(</span><span class="s">&quot;num_events&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">events</span><span class="p">)).</span>
            <span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;block data indexed&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">m</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;state indexing finished&quot;</span><span class="p">)</span>

    <span class="nx">step</span> <span class="o">:=</span> <span class="nx">steps</span><span class="p">[</span><span class="nx">commitPrev</span><span class="p">]</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">PostProcessing</span><span class="p">(</span><span class="nx">step</span><span class="p">.</span><span class="nx">Tree</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>
</details>
<p>As it was, this code was untestable.
Covering each possible case from this huge piece of logic would have required immense, complex, unreadable tests, that would break whenever a piece of this logic would change, and this would require a huge amount of maintenance effort.</p>
<p>To solve that massive problem, we refactored our original mapper into a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite-state machine</a> which replicates the same computation logic by applying transitions to a state.</p>
<details class="example">
<summary>mapper_new.go</summary>
<div class="highlight"><pre><span></span><code><span class="kn">package</span> <span class="nx">mapper</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;errors&quot;</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;sync&quot;</span>
    <span class="s">&quot;time&quot;</span>

    <span class="s">&quot;github.com/rs/zerolog&quot;</span>

    <span class="s">&quot;github.com/onflow/flow-go/ledger&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/ledger/complete/mtrie/trie&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/model/flow&quot;</span>

    <span class="s">&quot;github.com/optakt/flow-dps/models/dps&quot;</span>
<span class="p">)</span>

<span class="c1">// TransitionFunc is a function that is applied onto the state machine&#39;s</span>
<span class="c1">// state.</span>
<span class="kd">type</span> <span class="nx">TransitionFunc</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// Transitions is what applies transitions to the state of an FSM.</span>
<span class="kd">type</span> <span class="nx">Transitions</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">cfg</span>   <span class="nx">Config</span>
    <span class="nx">log</span>   <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span>
    <span class="nx">load</span>  <span class="nx">Loader</span>
    <span class="nx">chain</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Chain</span>
    <span class="nx">feed</span>  <span class="nx">Feeder</span>
    <span class="nx">read</span>  <span class="nx">dps</span><span class="p">.</span><span class="nx">Reader</span>
    <span class="nx">write</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Writer</span>
    <span class="nx">once</span>  <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="p">}</span>

<span class="c1">// NewTransitions returns a Transitions component using the given dependencies and using the given options</span>
<span class="kd">func</span> <span class="nx">NewTransitions</span><span class="p">(</span><span class="nx">log</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span><span class="p">,</span> <span class="nx">load</span> <span class="nx">Loader</span><span class="p">,</span> <span class="nx">chain</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">feed</span> <span class="nx">Feeder</span><span class="p">,</span> <span class="nx">read</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">write</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">options</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="o">*</span><span class="nx">Transitions</span> <span class="p">{</span>

    <span class="nx">cfg</span> <span class="o">:=</span> <span class="nx">DefaultConfig</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">option</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">options</span> <span class="p">{</span>
        <span class="nx">option</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cfg</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">Transitions</span><span class="p">{</span>
        <span class="nx">log</span><span class="p">:</span>   <span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span><span class="nx">Str</span><span class="p">(</span><span class="s">&quot;component&quot;</span><span class="p">,</span> <span class="s">&quot;mapper_transitions&quot;</span><span class="p">).</span><span class="nx">Logger</span><span class="p">(),</span>
        <span class="nx">cfg</span><span class="p">:</span>   <span class="nx">cfg</span><span class="p">,</span>
        <span class="nx">load</span><span class="p">:</span>  <span class="nx">load</span><span class="p">,</span>
        <span class="nx">chain</span><span class="p">:</span> <span class="nx">chain</span><span class="p">,</span>
        <span class="nx">feed</span><span class="p">:</span>  <span class="nx">feed</span><span class="p">,</span>
        <span class="nx">read</span><span class="p">:</span>  <span class="nx">read</span><span class="p">,</span>
        <span class="nx">write</span><span class="p">:</span> <span class="nx">write</span><span class="p">,</span>
        <span class="nx">once</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span><span class="p">{},</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">t</span>
<span class="p">}</span>

<span class="c1">// InitializeMapper initializes the mapper by either going into bootstrapping or</span>
<span class="c1">// into resuming, depending on the configuration.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">InitializeMapper</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusInitialize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for initializing mapper (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">BootstrapState</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusBootstrap</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusResume</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// BootstrapState bootstraps the state by loading the checkpoint if there is one</span>
<span class="c1">// and initializing the elements subsequently used by the FSM.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">BootstrapState</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusBootstrap</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for bootstrapping state (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// We always need at least one step in our forest, which is used as the</span>
    <span class="c1">// stopping point when indexing the payloads since the last finalized</span>
    <span class="c1">// block. We thus introduce an empty tree, with no paths and an</span>
    <span class="c1">// irrelevant previous commit.</span>
    <span class="nx">empty</span> <span class="o">:=</span> <span class="nx">trie</span><span class="p">.</span><span class="nx">NewEmptyMTrie</span><span class="p">()</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Save</span><span class="p">(</span><span class="nx">empty</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span><span class="p">)</span>

    <span class="c1">// The chain indexing will forward last to next and next to current height,</span>
    <span class="c1">// which will be the one for the checkpoint.</span>
    <span class="nx">first</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">(</span><span class="nx">empty</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">())</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">first</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit&quot;</span><span class="p">,</span> <span class="nx">first</span><span class="p">[:]).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;added empty tree to forest&quot;</span><span class="p">)</span>

    <span class="c1">// Then, we can load the root height and apply it to the state. That</span>
    <span class="c1">// will allow us to load the root blockchain data in the next step.</span>
    <span class="nx">height</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Root</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get root height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">height</span> <span class="p">=</span> <span class="nx">height</span>

    <span class="c1">// When bootstrapping, the loader injected into the mapper loads the root</span>
    <span class="c1">// checkpoint.</span>
    <span class="nx">tree</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">load</span><span class="p">.</span><span class="nx">Trie</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not load root trie: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">paths</span> <span class="o">:=</span> <span class="nx">allPaths</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Save</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="nx">first</span><span class="p">)</span>

    <span class="nx">second</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">()</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Uint64</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">).</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit&quot;</span><span class="p">,</span> <span class="nx">second</span><span class="p">[:]).</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;registers&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;added checkpoint tree to forest&quot;</span><span class="p">)</span>

    <span class="c1">// We have successfully bootstrapped. However, no chain data for the root</span>
    <span class="c1">// block has been indexed yet. This is why we &quot;pretend&quot; that we just</span>
    <span class="c1">// forwarded the state to this height, so we go straight to the chain data</span>
    <span class="c1">// indexing.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusIndex</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// ResumeIndexing resumes indexing the data from a previous run.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusResume</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for resuming indexing (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// When resuming, we want to avoid overwriting the `first` height in the</span>
    <span class="c1">// index with the height we are resuming from. Theoretically, all that would</span>
    <span class="c1">// be needed would be to execute a no-op on `once`, which would subsequently</span>
    <span class="c1">// be skipped in the height forwarding code. However, this bug was already</span>
    <span class="c1">// released, so we have databases where `first` was incorrectly set to the</span>
    <span class="c1">// height we resume from. In order to fix them, we explicitly write the</span>
    <span class="c1">// correct `first` height here again, while at the same time using `once` to</span>
    <span class="c1">// disable any subsequent attempts to write it.</span>
    <span class="nx">first</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Root</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get root height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">First</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">})</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not write first: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// We need to know what the last indexed height was at the point we stopped</span>
    <span class="c1">// indexing.</span>
    <span class="nx">last</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nx">Last</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get last height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// When resuming, the loader injected into the mapper rebuilds the trie from</span>
    <span class="c1">// the paths and payloads stored in the index database.</span>
    <span class="nx">tree</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">load</span><span class="p">.</span><span class="nx">Trie</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not restore index trie: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// After loading the trie, we should do a sanity check on its hash against</span>
    <span class="c1">// the commit we indexed for it.</span>
    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">())</span>
    <span class="nx">commit</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nx">Commit</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get last commit: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">hash</span> <span class="o">!=</span> <span class="nx">commit</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;restored trie hash does not match last commit (hash: %x, commit: %x)&quot;</span><span class="p">,</span> <span class="nx">hash</span><span class="p">,</span> <span class="nx">commit</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// At this point, we can store the restored trie in our forest, as the trie</span>
    <span class="c1">// for the last finalized block. We do not need to care about the parent</span>
    <span class="c1">// state commitment or the paths, as they should not be used.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">commit</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Save</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span><span class="p">)</span>

    <span class="c1">// Lastly, we just need to point to the next height. The chain indexing will</span>
    <span class="c1">// then proceed with the first non-indexed block and forward the state</span>
    <span class="c1">// commitments accordingly.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">height</span> <span class="p">=</span> <span class="nx">last</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1">// At this point, we should be able to start indexing the chain data for</span>
    <span class="c1">// the next height.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusIndex</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// IndexChain indexes chain data for the current height.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">IndexChain</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusIndex</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for indexing chain (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">log</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span><span class="nx">Uint64</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">).</span><span class="nx">Logger</span><span class="p">()</span>

    <span class="c1">// We try to retrieve the next header until it becomes available, which</span>
    <span class="c1">// means all data coming from the protocol state is available after this</span>
    <span class="c1">// point.</span>
    <span class="nx">header</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Header</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrUnavailable</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;waiting for next header&quot;</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">WaitInterval</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get header: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// At this point, we can retrieve the data from the consensus state. This is</span>
    <span class="c1">// a slight optimization for the live indexer, as it allows us to process</span>
    <span class="c1">// some data before the full execution data becomes available.</span>
    <span class="nx">guarantees</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Guarantees</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get guarantees: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">seals</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Seals</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get seals: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// We can also proceed to already indexing the data related to the consensus</span>
    <span class="c1">// state, before dealing with anything related to execution data, which</span>
    <span class="c1">// might go into the wait state.</span>
    <span class="nx">blockID</span> <span class="o">:=</span> <span class="nx">header</span><span class="p">.</span><span class="nx">ID</span><span class="p">()</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Height</span><span class="p">(</span><span class="nx">blockID</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Header</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">header</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index header: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Guarantees</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">guarantees</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index guarantees: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Seals</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">seals</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index seals: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Next, we try to retrieve the next commit until it becomes available,</span>
    <span class="c1">// at which point all the data coming from the execution data should be</span>
    <span class="c1">// available.</span>
    <span class="nx">commit</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Commit</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrUnavailable</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;waiting for next state commitment&quot;</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">WaitInterval</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get commit: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">collections</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Collections</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get collections: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">transactions</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get transactions: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">results</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Results</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get transaction results: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">events</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Events</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not get events: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Next, all we need to do is index the remaining data and we have fully</span>
    <span class="c1">// processed indexing for this block height.</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Commit</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">commit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index commit: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Collections</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">collections</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index collections: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">transactions</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index transactions: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Results</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index transaction results: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Events</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">events</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index events: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// At this point, we need to forward the `last` state commitment to</span>
    <span class="c1">// `next`, so we know what the state commitment was at the last finalized</span>
    <span class="c1">// block we processed. This will allow us to know when to stop when</span>
    <span class="c1">// walking back through the forest to collect trie updates.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">last</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span>

    <span class="c1">// Last but not least, we need to update `next` to point to the commit we</span>
    <span class="c1">// have just retrieved for the new block height. This is the sentinel that</span>
    <span class="c1">// tells us when we have collected enough trie updates for the forest to</span>
    <span class="c1">// have reached the next finalized block.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">commit</span>

    <span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;indexed blockchain data for finalized block&quot;</span><span class="p">)</span>

    <span class="c1">// After indexing the blockchain data, we can go back to updating the state</span>
    <span class="c1">// tree until we find the commit of the finalized block. This will allow us</span>
    <span class="c1">// to index the payloads then.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusUpdate</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// UpdateTree updates the state&#39;s tree. If the state&#39;s forest already matches with the next block&#39;s state commitment,</span>
<span class="c1">// it immediately returns and sets the state&#39;s status to StatusMatched.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusUpdate</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for updating tree (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">log</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span><span class="nx">Uint64</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">).</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">last</span><span class="p">[:]).</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;next&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span><span class="p">[:]).</span><span class="nx">Logger</span><span class="p">()</span>

    <span class="c1">// If the forest contains a tree for the commit of the next finalized block,</span>
    <span class="c1">// we have reached our goal, and we can go to the next step in order to</span>
    <span class="c1">// collect the register payloads we want to index for that block.</span>
    <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span><span class="p">[:]).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;matched commit of finalized block&quot;</span><span class="p">)</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusCollect</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="c1">// First, we get the next tree update from the feeder. We can skip it if</span>
    <span class="c1">// it doesn&#39;t have any updated paths, or if we can&#39;t find the tree to apply</span>
    <span class="c1">// it to in the forest. This usually means that it was meant for a pruned</span>
    <span class="c1">// branch of the execution forest.</span>
    <span class="nx">update</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Update</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrUnavailable</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">WaitInterval</span><span class="p">)</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;waiting for next trie update&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not feed update: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">parent</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">(</span><span class="nx">update</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">)</span>
    <span class="nx">tree</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Tree</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Warn</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;state commitment mismatch, retrieving next trie update&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="c1">// We then apply the update to the relevant tree, as retrieved from the</span>
    <span class="c1">// forest, and save the updated tree in the forest. If the tree is not new,</span>
    <span class="c1">// we should error, as that should not happen.</span>
    <span class="nx">paths</span><span class="p">,</span> <span class="nx">payloads</span> <span class="o">:=</span> <span class="nx">pathsPayloads</span><span class="p">(</span><span class="nx">update</span><span class="p">)</span>
    <span class="nx">tree</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">trie</span><span class="p">.</span><span class="nx">NewTrieWithUpdatedRegisters</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="nx">payloads</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not update tree: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Save</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>

    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">()</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit&quot;</span><span class="p">,</span> <span class="nx">hash</span><span class="p">[:]).</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;registers&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;updated tree with register payloads&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// CollectRegisters reads the payloads for the next block to be indexed from the state&#39;s forest, unless payload</span>
<span class="c1">// indexing is disabled.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">CollectRegisters</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">log</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span><span class="nx">Uint64</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">).</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span><span class="p">[:]).</span><span class="nx">Logger</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusCollect</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for collecting registers (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// If indexing payloads is disabled, we can bypass collection and indexing</span>
    <span class="c1">// of payloads and just go straight to forwarding the height to the next</span>
    <span class="c1">// finalized block.</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">SkipRegisters</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusForward</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="c1">// If we index payloads, we are basically stepping back from (and including)</span>
    <span class="c1">// the tree that corresponds to the next finalized block all the way up to</span>
    <span class="c1">// (and excluding) the tree for the last finalized block we indexed. To do</span>
    <span class="c1">// so, we will use the parent state commit to retrieve the parent trees from</span>
    <span class="c1">// the forest, and we use the paths we recorded changes on to retrieve the</span>
    <span class="c1">// changed payloads at each step.</span>
    <span class="nx">commit</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">for</span> <span class="nx">commit</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">last</span> <span class="p">{</span>

        <span class="c1">// We do this check only once, so that we don&#39;t need to do it for</span>
        <span class="c1">// each item we retrieve. The tree should always be there, but we</span>
        <span class="c1">// should check just to not fail silently.</span>
        <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Has</span><span class="p">(</span><span class="nx">commit</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not load tree (commit: %x)&quot;</span><span class="p">,</span> <span class="nx">commit</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// For each path, we retrieve the payload and add it to the registers we</span>
        <span class="c1">// will index later. If we already have a payload for the path, it is</span>
        <span class="c1">// more recent as we iterate backwards in time, so we can skip the</span>
        <span class="c1">// outdated payload.</span>
        <span class="c1">// NOTE: We read from the tree one by one here, as the performance</span>
        <span class="c1">// overhead is minimal compared to the disk i/o for badger, and it</span>
        <span class="c1">// allows us to ignore sorting of paths.</span>
        <span class="nx">tree</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Tree</span><span class="p">(</span><span class="nx">commit</span><span class="p">)</span>
        <span class="nx">paths</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Paths</span><span class="p">(</span><span class="nx">commit</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">path</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">paths</span> <span class="p">{</span>
            <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">registers</span><span class="p">[</span><span class="nx">path</span><span class="p">]</span>
            <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="nx">payloads</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">UnsafeRead</span><span class="p">([]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">{</span><span class="nx">path</span><span class="p">})</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">registers</span><span class="p">[</span><span class="nx">path</span><span class="p">]</span> <span class="p">=</span> <span class="nx">payloads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;batch&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;collected register batch for finalized block&quot;</span><span class="p">)</span>

        <span class="c1">// We now step back to the parent of the current state trie.</span>
        <span class="nx">parent</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Parent</span><span class="p">(</span><span class="nx">commit</span><span class="p">)</span>
        <span class="nx">commit</span> <span class="p">=</span> <span class="nx">parent</span>
    <span class="p">}</span>

    <span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;registers&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">registers</span><span class="p">)).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;collected all registers for finalized block&quot;</span><span class="p">)</span>

    <span class="c1">// At this point, we have collected all the payloads, so we go to the next</span>
    <span class="c1">// step, where we will index them.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusMap</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// MapRegisters maps the collected registers to the current block.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">MapRegisters</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusMap</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for indexing registers (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">log</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">With</span><span class="p">().</span><span class="nx">Uint64</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">).</span><span class="nx">Hex</span><span class="p">(</span><span class="s">&quot;commit&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span><span class="p">[:]).</span><span class="nx">Logger</span><span class="p">()</span>

    <span class="c1">// If there are no registers left to be indexed, we can go to the next step,</span>
    <span class="c1">// which is about forwarding the height to the next finalized block.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">registers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;indexed all registers for finalized block&quot;</span><span class="p">)</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusForward</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="c1">// We will now collect and index 1000 registers at a time. This gives the</span>
    <span class="c1">// FSM the chance to exit the loop between every 1000 payloads we index. It</span>
    <span class="c1">// doesn&#39;t really matter for badger if they are in random order, so this</span>
    <span class="c1">// way of iterating should be fine.</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="mi">1000</span>
    <span class="nx">paths</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="nx">payloads</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">payload</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">registers</span> <span class="p">{</span>
        <span class="nx">paths</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
        <span class="nx">payloads</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">payloads</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span>
        <span class="nb">delete</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">registers</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Then we store the (maximum) 1000 paths and payloads.</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Payloads</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="nx">payloads</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index registers: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">log</span><span class="p">.</span><span class="nx">Debug</span><span class="p">().</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;batch&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">)).</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;remaining&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">registers</span><span class="p">)).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;indexed register batch for finalized block&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// ForwardHeight increments the height at which the mapping operates, and updates the last indexed height.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="nx">ForwardHeight</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">StatusForward</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid status for forwarding height (%s)&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// After finishing the indexing of the payloads for a finalized block, or</span>
    <span class="c1">// skipping it, we should document the last indexed height. On the first</span>
    <span class="c1">// pass, we will also index the first indexed height here.</span>
    <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">First</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span> <span class="p">})</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index first height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">write</span><span class="p">.</span><span class="nx">Last</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;could not index last height: %w&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Now that we have indexed the heights, we can forward to the next height,</span>
    <span class="c1">// and reset the forest to free up memory.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="o">++</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">forest</span><span class="p">.</span><span class="nx">Reset</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">Info</span><span class="p">().</span><span class="nx">Uint64</span><span class="p">(</span><span class="s">&quot;height&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">height</span><span class="p">).</span><span class="nx">Msg</span><span class="p">(</span><span class="s">&quot;forwarded finalized block to next height&quot;</span><span class="p">)</span>

    <span class="c1">// Once the height is forwarded, we can set the status so that we index</span>
    <span class="c1">// the blockchain data next.</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusIndex</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>
</details>
<p>This refactoring effort allowed us to write simple and concise tests that call a transition function upon the state machine and make assertions upon the resulting state.</p>
<details class="example">
<summary>mapper_new_internal_test.go</summary>
<div class="highlight"><pre><span></span><code><span class="kn">package</span> <span class="nx">mapper</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;sync&quot;</span>
    <span class="s">&quot;testing&quot;</span>

    <span class="s">&quot;github.com/stretchr/testify/assert&quot;</span>
    <span class="s">&quot;github.com/stretchr/testify/require&quot;</span>

    <span class="s">&quot;github.com/onflow/flow-go/ledger&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/ledger/complete/mtrie/trie&quot;</span>
    <span class="s">&quot;github.com/onflow/flow-go/model/flow&quot;</span>

    <span class="s">&quot;github.com/optakt/flow-dps/models/dps&quot;</span>
    <span class="s">&quot;github.com/optakt/flow-dps/testing/mocks&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">TestNewTransitions</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case, without options&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">load</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">feed</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineFeeder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">read</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

        <span class="nx">tr</span> <span class="o">:=</span> <span class="nx">NewTransitions</span><span class="p">(</span><span class="nx">mocks</span><span class="p">.</span><span class="nx">NoopLogger</span><span class="p">,</span> <span class="nx">load</span><span class="p">,</span> <span class="nx">chain</span><span class="p">,</span> <span class="nx">feed</span><span class="p">,</span> <span class="nx">read</span><span class="p">,</span> <span class="nx">write</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">NotNil</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tr</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">chain</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">feed</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">feed</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">write</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">NotNil</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">once</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">DefaultConfig</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">cfg</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case, with option&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">load</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">feed</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineFeeder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">read</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>

        <span class="nx">skip</span> <span class="o">:=</span> <span class="kc">true</span>
        <span class="nx">tr</span> <span class="o">:=</span> <span class="nx">NewTransitions</span><span class="p">(</span><span class="nx">mocks</span><span class="p">.</span><span class="nx">NoopLogger</span><span class="p">,</span> <span class="nx">load</span><span class="p">,</span> <span class="nx">chain</span><span class="p">,</span> <span class="nx">feed</span><span class="p">,</span> <span class="nx">read</span><span class="p">,</span> <span class="nx">write</span><span class="p">,</span>
            <span class="nx">WithSkipRegisters</span><span class="p">(</span><span class="nx">skip</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">NotNil</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tr</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">chain</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">feed</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">feed</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">write</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">NotNil</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">once</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">NotEqual</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">DefaultConfig</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">cfg</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">skip</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">SkipRegisters</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">DefaultConfig</span><span class="p">.</span><span class="nx">WaitInterval</span><span class="p">,</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">WaitInterval</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_BootstrapState</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">)</span>

        <span class="c1">// Copy state in local scope so that we can override its SaveFunc without impacting other</span>
        <span class="c1">// tests running in parallel.</span>
        <span class="kd">var</span> <span class="nx">saveCalled</span> <span class="kt">bool</span>
        <span class="nx">forest</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="nx">forest</span><span class="p">.</span><span class="nx">SaveFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tree</span> <span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="nx">paths</span> <span class="p">[]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="nx">parent</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">saveCalled</span> <span class="p">{</span>
                <span class="nx">assert</span><span class="p">.</span><span class="nx">True</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">IsEmpty</span><span class="p">())</span>
                <span class="nx">assert</span><span class="p">.</span><span class="nx">Nil</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">paths</span><span class="p">)</span>
                <span class="nx">assert</span><span class="p">.</span><span class="nx">Zero</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
                <span class="nx">saveCalled</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">False</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">IsEmpty</span><span class="p">())</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Len</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">AllPayloads</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">paths</span><span class="p">))</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Len</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// Expect the three paths from leaves.</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">NotZero</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">BootstrapState</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;invalid state&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusForward</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">BootstrapState</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles failure to get root height&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">)</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">BootstrapState</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_IndexChain</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">HeaderFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeader</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">CollectionsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">LightCollection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCollections</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">GuaranteesFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">CollectionGuarantee</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericGuarantees</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">TransactionsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">TransactionBody</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericTransactions</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">ResultsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">TransactionResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericResults</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">EventsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Event</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericEvents</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">SealsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Seal</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericSeals</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">HeaderFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">header</span> <span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeader</span><span class="p">,</span> <span class="nx">header</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">commit</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">commit</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">HeightFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">blockID</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">Identifier</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeader</span><span class="p">.</span><span class="nx">ID</span><span class="p">(),</span> <span class="nx">blockID</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">CollectionsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">collections</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">LightCollection</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCollections</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nx">collections</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">GuaranteesFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">guarantees</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">CollectionGuarantee</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericGuarantees</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nx">guarantees</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">TransactionsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">transactions</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">TransactionBody</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericTransactions</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nx">transactions</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">ResultsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">results</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">TransactionResult</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericResults</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nx">results</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">EventsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">events</span> <span class="p">[]</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Event</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericEvents</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="nx">events</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">SealsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">seals</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Seal</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericSeals</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nx">seals</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles invalid status&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve commit&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure to index commit&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve header&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">HeaderFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure to index header&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">HeaderFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve transactions&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">TransactionsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">TransactionBody</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve transaction results&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">ResultsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">TransactionResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure to index transactions&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">ResultsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">TransactionResult</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve collections&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">CollectionsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">LightCollection</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure to index collections&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">CollectionsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">LightCollection</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve guarantees&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">GuaranteesFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">CollectionGuarantee</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure to index guarantees&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">GuaranteesFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">CollectionGuarantee</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve events&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">EventsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Event</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure to index events&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">EventsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="p">[]</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Event</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure to retrieve seals&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">SealsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Seal</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure to index seals&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">SealsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="p">[]</span><span class="o">*</span><span class="nx">flow</span><span class="p">.</span><span class="nx">Seal</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">IndexChain</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_UpdateTree</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">update</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericTrieUpdate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nx">tree</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericTrie</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case without match&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">)</span>

        <span class="nx">forest</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
        <span class="nx">forest</span><span class="p">.</span><span class="nx">SaveFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tree</span> <span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="nx">paths</span> <span class="p">[]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="nx">parent</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Parent is RootHash of the mocks.GenericTrie.</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">update</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">[:],</span> <span class="nx">parent</span><span class="p">[:])</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">ElementsMatch</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="nx">update</span><span class="p">.</span><span class="nx">Paths</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">NotZero</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tree</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">forest</span><span class="p">.</span><span class="nx">TreeFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">commit</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">update</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">[:],</span> <span class="nx">commit</span><span class="p">[:])</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">forest</span> <span class="p">=</span> <span class="nx">forest</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case with no available update temporarily&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">)</span>

        <span class="c1">// Set up the mock feeder to return an unavailable error on the first call and return successfully</span>
        <span class="c1">// to subsequent calls.</span>
        <span class="kd">var</span> <span class="nx">updateCalled</span> <span class="kt">bool</span>
        <span class="nx">feeder</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineFeeder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">feeder</span><span class="p">.</span><span class="nx">UpdateFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">TrieUpdate</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">!</span><span class="nx">updateCalled</span> <span class="p">{</span>
                <span class="nx">updateCalled</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">ErrUnavailable</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericTrieUpdate</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">feed</span> <span class="p">=</span> <span class="nx">feeder</span>

        <span class="nx">forest</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="nx">forest</span><span class="p">.</span><span class="nx">HasFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">updateCalled</span>
        <span class="p">}</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">forest</span> <span class="p">=</span> <span class="nx">forest</span>

        <span class="c1">// The first call should not error but should not change the status of the FSM to updating. It should</span>
        <span class="c1">// instead remain Updating until a match is found.</span>
        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>

        <span class="c1">// The second call is now successful and matches.</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusCollect</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case with match&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusCollect</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles invalid status&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles feeder update failure&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">feed</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineFeeder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">feed</span><span class="p">.</span><span class="nx">UpdateFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">TrieUpdate</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">)</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">forest</span> <span class="p">=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">feed</span> <span class="p">=</span> <span class="nx">feed</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles forest parent tree not found&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">forest</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
        <span class="nx">forest</span><span class="p">.</span><span class="nx">TreeFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusUpdate</span><span class="p">)</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">forest</span> <span class="p">=</span> <span class="nx">forest</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">UpdateTree</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_CollectRegisters</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">forest</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="nx">forest</span><span class="p">.</span><span class="nx">ParentFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">commit</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">commit</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusCollect</span><span class="p">)</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">forest</span> <span class="p">=</span> <span class="nx">forest</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">CollectRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusMap</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">wantPath</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPaths</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span><span class="p">,</span> <span class="nx">wantPath</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;indexing payloads disabled&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusCollect</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">SkipRegisters</span> <span class="p">=</span> <span class="kc">true</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">CollectRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Empty</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusForward</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles invalid status&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">CollectRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Empty</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles missing tree for commit&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusCollect</span><span class="p">)</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">forest</span> <span class="p">=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">CollectRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Empty</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_MapRegisters</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case with registers to write&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="c1">// Path 2 and 4 are the same so the map effectively contains 5 entries.</span>
        <span class="nx">testRegisters</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">{</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">PayloadsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">paths</span> <span class="p">[]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="nx">value</span> <span class="p">[]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="c1">// Expect the 5 entries from the map.</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Len</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">paths</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Len</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusMap</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span> <span class="p">=</span> <span class="nx">testRegisters</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">MapRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>

        <span class="c1">// Should not be StateIndexed because registers map was not empty.</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Empty</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusMap</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case no more registers left to write&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusMap</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">MapRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusForward</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles invalid status&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">testRegisters</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">{</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">)</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span> <span class="p">=</span> <span class="nx">testRegisters</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">MapRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">testRegisters</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">{</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPath</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericLedgerPayload</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">PayloadsFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="p">[]</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="p">[]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span> <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusMap</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">registers</span> <span class="p">=</span> <span class="nx">testRegisters</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">MapRegisters</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_ForwardHeight</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="kd">var</span> <span class="p">(</span>
            <span class="nx">firstCalled</span> <span class="kt">int</span>
            <span class="nx">lastCalled</span>  <span class="kt">int</span>
        <span class="p">)</span>
        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">FirstFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">firstCalled</span><span class="o">++</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="o">+</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">lastCalled</span><span class="p">),</span> <span class="nx">height</span><span class="p">)</span>
            <span class="nx">lastCalled</span><span class="o">++</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">forest</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="nx">forest</span><span class="p">.</span><span class="nx">ResetFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">finalized</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">finalized</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusForward</span><span class="p">)</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">forest</span> <span class="p">=</span> <span class="nx">forest</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ForwardHeight</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>

        <span class="c1">// Reset status to allow next call.</span>
        <span class="nx">st</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">StatusForward</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ForwardHeight</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>

        <span class="c1">// First should have been called only once.</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">firstCalled</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles invalid status&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ForwardHeight</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer error on first&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">FirstFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusForward</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ForwardHeight</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer error on last&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">write</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusForward</span><span class="p">)</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ForwardHeight</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_InitializeMapper</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;switches state to BootstrapState if configured to do so&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusInitialize</span><span class="p">)</span>

        <span class="nx">tr</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">BootstrapState</span> <span class="p">=</span> <span class="kc">true</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">InitializeMapper</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusBootstrap</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;switches state to StatusResume if no bootstrapping configured&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusInitialize</span><span class="p">)</span>

        <span class="nx">tr</span><span class="p">.</span><span class="nx">cfg</span><span class="p">.</span><span class="nx">BootstrapState</span> <span class="p">=</span> <span class="kc">false</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">InitializeMapper</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusResume</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles invalid status&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusForward</span><span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">InitializeMapper</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">TestTransitions_ResumeIndexing</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">header</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeader</span>
    <span class="nx">tree</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericTrie</span>
    <span class="nx">commit</span> <span class="o">:=</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">RootHash</span><span class="p">())</span>
    <span class="nx">differentCommit</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;nominal case&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">writer</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">writer</span><span class="p">.</span><span class="nx">FirstFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">height</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>

            <span class="k">return</span> <span class="nx">commit</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusResume</span><span class="p">,</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withWriter</span><span class="p">(</span><span class="nx">writer</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">require</span><span class="p">.</span><span class="nx">NoError</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">StatusIndex</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">last</span><span class="p">)</span>
        <span class="nx">assert</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">commit</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles chain failure on Root&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">commit</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusResume</span><span class="p">,</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles writer failure on First&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">writer</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">writer</span><span class="p">.</span><span class="nx">FirstFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">commit</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusResume</span><span class="p">,</span>
            <span class="nx">withWriter</span><span class="p">(</span><span class="nx">writer</span><span class="p">),</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles reader failure on Last&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">commit</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusResume</span><span class="p">,</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles reader failure on Commit&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">flow</span><span class="p">.</span><span class="nx">DummyStateCommitment</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusResume</span><span class="p">,</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles loader failure on Trie&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericError</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">commit</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusResume</span><span class="p">,</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles mismatch between tree root hash and indexed commit&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">differentCommit</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusResume</span><span class="p">,</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">Run</span><span class="p">(</span><span class="s">&quot;handles invalid status&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Parallel</span><span class="p">()</span>

        <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">chain</span><span class="p">.</span><span class="nx">RootFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">loader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">loader</span><span class="p">.</span><span class="nx">TrieFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">trie</span><span class="p">.</span><span class="nx">MTrie</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">tree</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">reader</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">LastFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">header</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">reader</span><span class="p">.</span><span class="nx">CommitFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">flow</span><span class="p">.</span><span class="nx">StateCommitment</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">commit</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">tr</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">baselineFSM</span><span class="p">(</span>
            <span class="nx">t</span><span class="p">,</span>
            <span class="nx">StatusForward</span><span class="p">,</span>
            <span class="nx">withReader</span><span class="p">(</span><span class="nx">reader</span><span class="p">),</span>
            <span class="nx">withLoader</span><span class="p">(</span><span class="nx">loader</span><span class="p">),</span>
            <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nx">ResumeIndexing</span><span class="p">(</span><span class="nx">st</span><span class="p">)</span>

        <span class="nx">assert</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">baselineFSM</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">Status</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="kd">func</span><span class="p">(</span><span class="nx">tr</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">))</span> <span class="p">(</span><span class="o">*</span><span class="nx">Transitions</span><span class="p">,</span> <span class="o">*</span><span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Helper</span><span class="p">()</span>

    <span class="nx">load</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineLoader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">chain</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineChain</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">feeder</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineFeeder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">read</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineReader</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">write</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="nx">forest</span> <span class="o">:=</span> <span class="nx">mocks</span><span class="p">.</span><span class="nx">BaselineForest</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>

    <span class="nx">once</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span><span class="p">{}</span>
    <span class="nx">doneCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>

    <span class="nx">tr</span> <span class="o">:=</span> <span class="nx">Transitions</span><span class="p">{</span>
        <span class="nx">cfg</span><span class="p">:</span> <span class="nx">Config</span><span class="p">{</span>
            <span class="nx">BootstrapState</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="nx">SkipRegisters</span><span class="p">:</span>  <span class="kc">false</span><span class="p">,</span>
            <span class="nx">WaitInterval</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="nx">log</span><span class="p">:</span>   <span class="nx">mocks</span><span class="p">.</span><span class="nx">NoopLogger</span><span class="p">,</span>
        <span class="nx">load</span><span class="p">:</span>  <span class="nx">load</span><span class="p">,</span>
        <span class="nx">chain</span><span class="p">:</span> <span class="nx">chain</span><span class="p">,</span>
        <span class="nx">feed</span><span class="p">:</span>  <span class="nx">feeder</span><span class="p">,</span>
        <span class="nx">read</span><span class="p">:</span>  <span class="nx">read</span><span class="p">,</span>
        <span class="nx">write</span><span class="p">:</span> <span class="nx">write</span><span class="p">,</span>
        <span class="nx">once</span><span class="p">:</span>  <span class="nx">once</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
        <span class="nx">opt</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tr</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">st</span> <span class="o">:=</span> <span class="nx">State</span><span class="p">{</span>
        <span class="nx">forest</span><span class="p">:</span>    <span class="nx">forest</span><span class="p">,</span>
        <span class="nx">status</span><span class="p">:</span>    <span class="nx">status</span><span class="p">,</span>
        <span class="nx">height</span><span class="p">:</span>    <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericHeight</span><span class="p">,</span>
        <span class="nx">last</span><span class="p">:</span>      <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="nx">next</span><span class="p">:</span>      <span class="nx">mocks</span><span class="p">.</span><span class="nx">GenericCommit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="nx">registers</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span><span class="o">*</span><span class="nx">ledger</span><span class="p">.</span><span class="nx">Payload</span><span class="p">),</span>
        <span class="nx">done</span><span class="p">:</span>      <span class="nx">doneCh</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">tr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">st</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">withLoader</span><span class="p">(</span><span class="nx">load</span> <span class="nx">Loader</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tr</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">load</span> <span class="p">=</span> <span class="nx">load</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">withChain</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Chain</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tr</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">withFeeder</span><span class="p">(</span><span class="nx">feed</span> <span class="nx">Feeder</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tr</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">feed</span> <span class="p">=</span> <span class="nx">feed</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">withReader</span><span class="p">(</span><span class="nx">read</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tr</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">read</span> <span class="p">=</span> <span class="nx">read</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">withWriter</span><span class="p">(</span><span class="nx">write</span> <span class="nx">dps</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tr</span> <span class="o">*</span><span class="nx">Transitions</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tr</span><span class="p">.</span><span class="nx">write</span> <span class="p">=</span> <span class="nx">write</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</details>
<h2 id="integration-tests">Integration Tests</h2>
<p>Integration tests are essential to ensure that components work together as expected.
Those tests are usually much heavier and slower than unit tests, since they use real components instead of simple mocks, and often might run filesystem or network operations, wait for things to happen, or even run heavy computational tasks.</p>
<p>Integration tests should always be specified in a separate test package and never run internally within the tested package.</p>
<h3 id="build-tag">Build Tag</h3>
<p>Because integration tests are inherently slower than unit tests, they are placed in specific files that are suffixed with <code>_integration_test.go</code> and those files start with a build tag directive which prevents them from running unless the <code>go test</code> command is called with the <code>integration</code> tag.</p>
<p>Both syntaxes should be specified, the <code>&lt;go1.17</code> one which is <code>+build &lt;tag&gt;</code> as well as the <code>&gt;=go1.17</code> one which is <code>go:build &lt;tag&gt;</code>.
The former will be dropped when we feel like it is no longer relevant to support go 1.16 and prior.</p>
<div class="highlight"><pre><span></span><code><span class="c1">//go:build integration</span>
<span class="c1">// +build integration</span>

<span class="kn">package</span> <span class="nx">dps_test</span>
</code></pre></div>
<h2 id="examples">Examples</h2>
<p>In Go, good package documentation includes not only comments for each public type and method, but also runnable examples and benchmarks in some cases.
Godoc allows defining examples which are verified by running them as tests and can be manually launched by readers of the documentation on the package's Godoc webpage.</p>
<p>As for typical tests, examples are functions that reside in a package's <code>_test.go</code> files.
Unlike normal test functions, though, example functions take no arguments and begin with the word <code>Example</code> instead of <code>Test</code>.</p>
<p>In order to specify what is the expected output of a given example, a comment has to be written at the end of the <code>Example</code> function, in the form of <code>// Output: &lt;expected output&gt;</code>.
If this is missing, examples will not be executed and therefore not included in the documentation.</p>
<h2 id="benchmarks">Benchmarks</h2>
<p>When a package exposes a performance-critical piece of code, it should be benchmarked, and benchmark tests must be available for anyone to reproduce the benchmark using their hardware.
Writing benchmark results in a markdown file without providing a way to reproduce them is irrelevant.</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../design/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Design Principles" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Design Principles
            </div>
          </div>
        </a>
      
      
        
        <a href="../style/go/" class="md-footer__link md-footer__link--next" aria-label="Next: Go" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Go
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2021 Optakt
          </div>
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.sections", "toc.integrate"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.fcfe8b6d.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.b1047164.min.js"></script>
      
    
  </body>
</html>